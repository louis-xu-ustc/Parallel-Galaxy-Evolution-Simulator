<section class="main-content">
    <h2>
        <a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span
                class="octicon octicon-link"></span></a><b>Competition</b></h2>

    <h3><b>Parallel Galaxy Evolution Simulator</b></h3>

    <p> We implemented a galaxy evolution simulator using two kinds of algorithms: Barnes-Hut algorithm and Morton-Code
        based algorithm. Then, we paralleled these sequential algorithms using CUDA and compared the performance
        on latedays cluster that has NVidia Tesla K40m.
    </p>

    <h3><b>Major Technical challenges</b></h3>
    <p>
    <ul>
        <li>
            The first technical challenges is to implement the sequential algorithms correctly. We came out with the
            second
            sequential algorithm based on the idea in this paper that introduces a parallel version of N-body problems.
            <a href="http://www.sciencedirect.com/science/article/pii/S0021999111007364">The reference can be
                found here.</a>The implementation in this paper is complex since it involves lots of parallel techniques
            to speedup the program. It takes time to understand how the algorithm works and then come out with the
            sequential algorithm.
        </li>
        <li>
            Barnes Hut Algorithm - Tree construction on GPU. In host machine setting, we can allocate new tree nodes on-the-fly.
            However, in GPU setting, we need to allocate space for the tree ahead of time. We used array-based layout,
            instead of pointer based layout. We “Allocate” internal node in the memory and use another array to maintain
            the relationship between parent node and children nodes.
        </li>
        <li>
            Barnes Hut Algorithm - Force calculation on GPU. In OpenMp threaded setting, we can simply parallel the processing of different nodes.
            However, CUDA supported recursive tree traversal is of very low efficiency and its recursive depth restricted.
            Also, unplanned scheduling of nodes onto warps may not have similar traversal depth and since warps execute
            in lockstep, serious thread divergence problem heavily strikes the performance of the program. To resolve this,
            we have to implement tree traversal with program-managed stack. We also sort the leaf nodes based on their x and y locations.
            By so doing, spatially closer nodes are more likely to have similar traversal depth and hence can be processed in the same warp,
            resulting in less thread divergence.
        </li>
        <li>
            Barnes Hut Algorithm - lockfree atomic operations to control access to shared data;
            special instructions (__threadfence, __syncthreads, and etc.) to guarantee correctness of the program;
            persist data in GPU between different iterations;
        </li>
    </ul>
    </p>
    <h3><b>Preliminary Result</b></h3>
    <ul>
        <div align="center">
            <img style='height: 80%; width: 80%; object-fit: contain' src="img/simulator_without_bouds.jpg"/><br/> <br/>
            <strong>Figure 1. Barnus-Hut without bounds</strong>
        </div>
        <p>
            <strong>Figure 1</strong> depicts the spiral pattern of galaxy evolution using sequential Barnus-Hut method.
        </p>
        <div align="center">
            <img style='height: 80%; width: 80%; object-fit: contain' src="img/simulator_with_bouds.jpg"/><br/> <br/>
            <strong>Figure 2. Barnus-Hut with bounds</strong></div>
        <p>
            <strong>Figure 2</strong> depicts the spiral pattern of galaxy evolution using sequential Barnus-Hut method
            and also the
            bounds of quad-tree in that iteration during the simulation period.
        </p>
        <div align="center">
            <img style='height: 80%; width: 80%; object-fit: contain' src="img/morton_with_bouds.png"/><br/> <br/>
            <strong>Figure 3. MortonCode with bounds</strong>
        </div>
        <p>
            <strong>Figure 3</strong> depicts the spiral pattern of galaxy evolution using sequential MortonCode method
            and also
            the bounds of the morton tree during the iteration period. This picture also shows the different bound
            pattern
            since the way to build the tree is different compared with the previous Barnus-Hut's Quad-Tree.
        </p>

        <div align="center">
          <img style='height: 80%; width: 80%; object-fit: contain' src="img/Running time (ms:iteration) as Increase of  Galaxy Size.png"/><br/> <br/>
          <strong>Figure 4. performance comparison of the four versions</strong>
        </div>
        <p>
            <strong>Figure 4</strong> depicts performance of the two algorithms with sequential and parallel version.
        </p>

        <div align="center">
          <img style='height: 80%; width: 80%; object-fit: contain' src="img/Running time (ms:iteration) as Increase of  Objects per Galaxy .png"/><br/> <br/>
          <strong>Figure 5. performance comparison of the four versions</strong>
        </div>
        <p>
            <strong>Figure 5</strong> depicts performance of the two algorithms with sequential and parallel version.
        </p>

        <div align="center">
          <img style='height: 80%; width: 80%; object-fit: contain' src="img/Running time (ms:iteration) as Increase of Number of Galaxy.jpg"/><br/> <br/>
          <strong>Figure 6. performance comparison of the four versions</strong>
        </div>
        <p>
            <strong>Figure 6</strong> depicts performance of the two algorithms with sequential and parallel version.
        </p>

        <div align="center">
          <img style='height: 80%; width: 80%; object-fit: contain' src="img/BH and MC's speedup compared to correspronding Seq Version As the increase of GALAXY SIZE.png"/><br/> <br/>
          <strong>Figure 7. performance comparison of the four versions</strong>
        </div>
        <p>
            <strong>Figure 7</strong> depicts performance of the two algorithms with sequential and parallel version.
        </p>

        <div align="center">
          <img style='height: 80%; width: 80%; object-fit: contain' src="img/BH and MC's speedup compared to correspronding Seq Version as the increase of Galaxy.png"/><br/> <br/>
          <strong>Figure 8. performance comparison of the four versions</strong>
        </div>
        <p>
            <strong>Figure 8</strong> depicts performance of the two algorithms with sequential and parallel version.
        </p>

        <div align="center">
          <img style='height: 80%; width: 80%; object-fit: contain' src="img/BH and MC's speedup compared to correspronding Seq Version As the increase of Objects Per Galaxy.png"/><br/> <br/>
          <strong>Figure 9. performance comparison of the four versions</strong>
        </div>
        <p>
            <strong>Figure 9</strong> depicts performance of the two algorithms with sequential and parallel version.
        </p>

    </ul>
    <h3><b>Summary of the Expected Show</b></h3>
    <p>
    <ul>
        <li>
            we'll demo a short video of the galaxy simulation and shows the performance speedup after using parallel
            techniques.
        </li>
    </ul>

    </p>

    <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/louis-xu-ustc/Parallel-Galaxy-Evolution-Simulator">Parallel Galaxy Evolution Simulator</a> is maintained by <a
                href="https://github.com/louis-xu-ustc">louis-xu-ustc</a>.</span>

        <span class="site-footer-credits">This page was generated by <a
                href="https://pages.github.com">GitHub Pages</a> using the <a
                href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a
                href="https://twitter.com/jasonlong">Jason Long</a>.</span>
    </footer>

</section>
